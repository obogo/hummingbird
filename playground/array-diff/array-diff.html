<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title></title>
</head>
<body>
<script>
var arrayPool = [],
        objectPool = [];

var largeArraySize = 75;

//[].map || (           // if arrays have no map
//        Array.prototype.map = // set the prototype's map
//                function (             // to a function
//                                       a                   // that takes a mapping function
//                                       /*, thisp */        // and an optional scope.
//                        ) {
//                    for (
//                            var b = this      // cache `this` and
//                                    , c = b.length  // the array's length,
//                                    , d = []        // create the return array
//                                    , e = 0         // and initialize the cursor,
//                                    , f             // and cache undefined.
//                            ; e < b;        // while the cursor is less than the length
//                            ) d[e] =            // set the result member
//                                    e in b            // if it originally exists,
//                            ? a.call(       // to the given function, called with
//                            arguments[1], // the optional scope,
//                            b[e],         // existing member,
//                            e++,          // member index, and
//                            b)           // current scope,
//                            : f;            // or to undefined otherwise.
//                    return d          // return the result.
//                });

var argsClass = '[object Arguments]',
        arrayClass = '[object Array]',
        boolClass = '[object Boolean]',
        dateClass = '[object Date]',
        funcClass = '[object Function]',
        numberClass = '[object Number]',
        objectClass = '[object Object]',
        regexpClass = '[object RegExp]',
        stringClass = '[object String]';

function baseIndexOf(array, value, fromIndex) {
    var index = (fromIndex || 0) - 1,
            length = array ? array.length : 0;

    while (++index < length) {
        if (array[index] === value) {
            return index;
        }
    }
    return -1;
}

function cacheIndexOf(cache, value) {
    var type = typeof value;
    cache = cache.cache;

    if (type == 'boolean' || value == null) {
        return cache[value] ? 0 : -1;
    }
    if (type != 'number' && type != 'string') {
        type = 'object';
    }
    var key = type == 'number' ? value : keyPrefix + value;
    cache = (cache = cache[type]) && cache[key];

    return type == 'object'
            ? (cache && baseIndexOf(cache, value) > -1 ? 0 : -1)
            : (cache ? 0 : -1);
}

function releaseArray(array) {
    array.length = 0;
    if (arrayPool.length < maxPoolSize) {
        arrayPool.push(array);
    }
}

function releaseObject(object) {
    var cache = object.cache;
    if (cache) {
        releaseObject(cache);
    }
    object.array = object.cache = object.criteria = object.object = object.number = object.string = object.value = null;
    if (objectPool.length < maxPoolSize) {
        objectPool.push(object);
    }
}

//function map(collection, callback, thisArg) {
//    var index = -1,
//            length = collection ? collection.length : 0;
//
//    callback = lodash.createCallback(callback, thisArg, 3);
//    if (typeof length == 'number') {
//        var result = Array(length);
//        while (++index < length) {
//            result[index] = callback(collection[index], index, collection);
//        }
//    } else {
//        result = [];
//        forOwn(collection, function(value, key, collection) {
//            result[++index] = callback(value, key, collection);
//        });
//    }
//    return result;
//}


/* global validators */
var validators = {};
//validators.isWindow = function (obj) {
//    return obj && obj.document && obj.location && obj.alert && obj.setInterval;
//}

//validators.isString = function isString(val) {
//    return typeof val === 'string';
//};

validators.isArray = function (val) {
    return val ? !!val.isArray : false;
};

//validators.isArrayLike = function (obj) {
//    if (obj == null || validators.isWindow(obj)) {
//        return false;
//    }
//
//    var length = obj.length;
//
//    if (obj.nodeType === 1 && length) {
//        return true;
//    }
//
//    return validators.isString(obj) || validators.isArray(obj) || length === 0 ||
//            typeof length === 'number' && length > 0 && (length - 1) in obj;
//};
//
//validators.isFunction = function (val) {
//    return typeof val === 'function';
//};

validators.isArguments = function (value) {
    return value && typeof value == 'object' && typeof value.length == 'number' &&
            toString.call(value) == argsClass || false;
}

var formatters = {};
formatters.flatten = function (array, isShallow, isStrict, fromIndex) {
    var index = (fromIndex || 0) - 1,
            length = array ? array.length : 0,
            result = [];

    while (++index < length) {
        var value = array[index];

        if (value && typeof value == 'object' && typeof value.length == 'number'
                && (validators.isArray(value) || validators.isArguments(value))) {
            // recursively flatten arrays (susceptible to call stack limits)
            if (!isShallow) {
                value = formatters.baseFlatten(value, isShallow, isStrict);
            }
            var valIndex = -1,
                    valLength = value.length,
                    resIndex = result.length;

            result.length += valLength;
            while (++valIndex < valLength) {
                result[resIndex++] = value[valIndex];
            }
        } else if (!isStrict) {
            result.push(value);
        }
    }
    return result;
};

formatters.uniq = function (array, isSorted, callback) {
    var index = -1,
            indexOf = baseIndexOf,
            length = array ? array.length : 0,
            result = [];

    var isLarge = !isSorted && length >= largeArraySize && indexOf === baseIndexOf,
            seen = (callback || isLarge) ? getArray() : result;

    if (isLarge) {
        var cache = createCache(seen);
        indexOf = cacheIndexOf;
        seen = cache;
    }
    while (++index < length) {
        var value = array[index],
                computed = callback ? callback(value, index, array) : value;

        if (isSorted
                ? !index || seen[seen.length - 1] !== computed
                : indexOf(seen, computed) < 0
                ) {
            if (callback || isLarge) {
                seen.push(computed);
            }
            result.push(value);
        }
    }
    if (isLarge) {
        releaseArray(seen.array);
        releaseObject(seen);
    } else if (callback) {
        releaseArray(seen);
    }
    return result;
};

formatters.union = function () {
    return formatters.uniq(formatters.flatten(arguments, true, true));
}

var map = function (arr, property) {
    var m = arr.map(makeKv);

    function makeKv(item, index) {
        var ret = {};
        ret[item[property]] = index;
        return ret;
    };

    console.log("m : ", m);
};


var helpers = {};
helpers.forEach = function (obj, iterator, context) {
    var key, length;
    if (obj) {
        if (validators.isFunction(obj)) {
            for (key in obj) {
                // Need to check if hasOwnProperty exists,
                // as on IE8 the result of querySelectorAll is an object without a hasOwnProperty function
                if (key !== 'prototype' && key !== 'length' && key !== 'name' && (!obj.hasOwnProperty || obj.hasOwnProperty(key))) {
                    iterator.call(context, obj[key], key);
                }
            }
        } else if (validators.isArray(obj) || validators.isArrayLike(obj)) {
            for (key = 0, length = obj.length; key < length; key++) {
                iterator.call(context, obj[key], key);
            }
        } else if (obj.forEach && obj.forEach !== forEach) {
            obj.forEach(iterator, context);
        } else {
            for (key in obj) {
                if (obj.hasOwnProperty(key)) {
                    iterator.call(context, obj[key], key);
                }
            }
        }
    }
    return obj;
};


// Longest Common Substring
var indexMap = function (list) {
    var map = {};
    list.forEach(function (each, i) {
        map[each] = map[each] || [];
        map[each].push(i)
    });
    return map
};

var longestCommonSubstring = function (seq1, seq2) {
    var result = {startString1: 0, startString2: 0, length: 0}
    var indexMapBefore = indexMap(seq1)
    var previousOverlap = []
    seq2.forEach(function (eachAfter, indexAfter) {
        var overlapLength
        var overlap = []
        var indexesBefore = indexMapBefore[eachAfter] || []
        indexesBefore.forEach(function (indexBefore) {
            overlapLength = ((indexBefore && previousOverlap[indexBefore - 1]) || 0) + 1;
            if (overlapLength > result.length) {
                result.length = overlapLength;
                result.startString1 = indexBefore - overlapLength + 1;
                result.startString2 = indexAfter - overlapLength + 1;
            }
            overlap[indexBefore] = overlapLength
        })
        previousOverlap = overlap
    })
    return result
}

// array diff
var diff = function (before, after) {
    debugger;
    var commonSeq = longestCommonSubstring(before, after)
    var startBefore = commonSeq.startString1;
    var startAfter = commonSeq.startString2;
    if (commonSeq.length == 0) {
        var result = before.map(function (each) {
            return ['-', each]
        });
        return result.concat(after.map(function (each) {
            return ['+', each]
        }))
    }
    var beforeLeft = before.slice(0, startBefore);
    var afterLeft = after.slice(0, startAfter);
    var equal = after.slice(startAfter, startAfter + commonSeq.length)
            .map(function (each) {
                return ['=', each]
            });
    var beforeRight = before.slice(startBefore + commonSeq.length);
    var afterRight = after.slice(startAfter + commonSeq.length);
    return formatters.union(diff(beforeLeft, afterLeft), equal, diff(beforeRight, afterRight))
};

var orderedSetDiff = function (before, after) {
    var diffRes = diff(before, after);
    var result = [];
    helpers.forEach(diffRes, function (each) {
        switch (each[0]) {
            case '=':
                result.push(each);
                break;
            case '-':
                result.push((after.indexOf(each[1]) > -1) ? ['x', each[1]] : ['-', each[1]]);
                break;
            case '+':
                result.push((before.indexOf(each[1]) > -1) ? ['p', each[1]] : ['+', each[1]]);
        }
    });
    return result
};

//var compress = function (diff) {
//    var result = [];
//    var modifier;
//    var section = [];
//    helpers.forEach(diff, function (each) {
//        if (modifier && (each[0] == modifier)) {
//            section.push(each[1])
//        } else {
//            if (modifier) result.push([modifier, section]);
//            section = [each[1]];
//            modifier = each[0]
//        }
//    });
//    if (modifier) result.push([modifier, section]);
//    return result
//}
</script>
<script>
    var before = [1, 2, 3, 4, 5];
    var after = [1, 2, 3, 4, 7, 5];
    //    var result = longestCommonSubstring(before, after);
    //    console.log(result);

    //    var before = [1, 2, 3, 4];
    //    var after = [2, 1, 5];
    //    var diffExpected = [
    //        ['x', 1],
    //        ['=', 2],
    //        ['-', 3],
    //        ['-', 4],
    //        ['p', 1],
    //        ['+', 5]
    //    ];
    var diffRes = diff(before, after);
    console.log(diffRes);
</script>
</body>
</html>