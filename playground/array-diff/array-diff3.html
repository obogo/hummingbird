<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title></title>
    <!--<script src="array-diff/node_modules/underscore/underscore.js"></script>-->
    <!--<script src="array-diff/node_modules/longest-common-substring/index.js"></script>-->
</head>
<body>
<script>
// :: HELPERS :: //
Array.prototype.isArray = true;
Object.defineProperty(Array.prototype, "isArray", {
    enumerable: false,
    writable: true
});


var arrayPool = [],
        objectPool = [];

var largeArraySize = 75;

var argsClass = '[object Arguments]';

function baseIndexOf(array, value, fromIndex) {
    var index = (fromIndex || 0) - 1,
            length = array ? array.length : 0;

    while (++index < length) {
        if (array[index] === value) {
            return index;
        }
    }
    return -1;
}

function cacheIndexOf(cache, value) {
    var type = typeof value;
    cache = cache.cache;

    if (type == 'boolean' || value == null) {
        return cache[value] ? 0 : -1;
    }
    if (type != 'number' && type != 'string') {
        type = 'object';
    }
    var key = type == 'number' ? value : keyPrefix + value;
    cache = (cache = cache[type]) && cache[key];

    return type == 'object'
            ? (cache && baseIndexOf(cache, value) > -1 ? 0 : -1)
            : (cache ? 0 : -1);
}

function releaseArray(array) {
    array.length = 0;
    if (arrayPool.length < maxPoolSize) {
        arrayPool.push(array);
    }
}

function releaseObject(object) {
    var cache = object.cache;
    if (cache) {
        releaseObject(cache);
    }
    object.array = object.cache = object.criteria = object.object = object.number = object.string = object.value = null;
    if (objectPool.length < maxPoolSize) {
        objectPool.push(object);
    }
}


var validators = {};

validators.isArray = function (val) {
    return val ? !!val.isArray : false;
};

validators.isArguments = function (value) {
    return value && typeof value == 'object' && typeof value.length == 'number' &&
            toString.call(value) == argsClass || false;
};


var formatters = {};
formatters.flatten = function (array, isShallow, isStrict, fromIndex) {
    var index = (fromIndex || 0) - 1,
            length = array ? array.length : 0,
            result = [];

    while (++index < length) {
        var value = array[index];

        if (value && typeof value == 'object' && typeof value.length == 'number'
                && (validators.isArray(value) || validators.isArguments(value))) {
            // recursively flatten arrays (susceptible to call stack limits)
            if (!isShallow) {
                value = formatters.flatten(value, isShallow, isStrict);
            }
            var valIndex = -1,
                    valLength = value.length,
                    resIndex = result.length;

            result.length += valLength;
            while (++valIndex < valLength) {
                result[resIndex++] = value[valIndex];
            }
        } else if (!isStrict) {
            result.push(value);
        }
    }
    return result;
};

formatters.uniq = function (array, isSorted, callback) {
    var index = -1,
            indexOf = baseIndexOf,
            length = array ? array.length : 0,
            result = [];

    var isLarge = !isSorted && length >= largeArraySize && indexOf === baseIndexOf,
            seen = (callback || isLarge) ? getArray() : result;

    if (isLarge) {
        var cache = createCache(seen);
        indexOf = cacheIndexOf;
        seen = cache;
    }
    while (++index < length) {
        var value = array[index],
                computed = callback ? callback(value, index, array) : value;

        if (isSorted
                ? !index || seen[seen.length - 1] !== computed
                : indexOf(seen, computed) < 0
                ) {
            if (callback || isLarge) {
                seen.push(computed);
            }
            result.push(value);
        }
    }
    if (isLarge) {
        releaseArray(seen.array);
        releaseObject(seen);
    } else if (callback) {
        releaseArray(seen);
    }
    return result;
};

formatters.union = function () {
    return formatters.uniq(formatters.flatten(arguments, true, true));
}


// :: LCS :: //
var indexMap = function (list) {
    var map = {}
    list.forEach(function (each, i) {
        map[each] = map[each] || []
        map[each].push(i)
    })
    return map
}

var longestCommonSubstring = function (seq1, seq2) {
    var result = {startString1: 0, startString2: 0, length: 0}
    var indexMapBefore = indexMap(seq1)
    var previousOverlap = []
    seq2.forEach(function (eachAfter, indexAfter) {
        var overlapLength
        var overlap = []
        var indexesBefore = indexMapBefore[eachAfter] || []
        indexesBefore.forEach(function (indexBefore) {
            overlapLength = ((indexBefore && previousOverlap[indexBefore - 1]) || 0) + 1;
            if (overlapLength > result.length) {
                result.length = overlapLength;
                result.startString1 = indexBefore - overlapLength + 1;
                result.startString2 = indexAfter - overlapLength + 1;
            }
            overlap[indexBefore] = overlapLength
        })
        previousOverlap = overlap
    })
    return result
}

var diff = function (before, after) {
    var commonSeq = longestCommonSubstring(before, after)
    var startBefore = commonSeq.startString1
    var startAfter = commonSeq.startString2
    if (commonSeq.length == 0) {
        var result = before.map(function (each) {
            return ['-', each]
        })
        return result.concat(after.map(function (each) {
            return ['+', each]
        }))
    }
    var beforeLeft = before.slice(0, startBefore)
    var afterLeft = after.slice(0, startAfter)
    var equal = after.slice(startAfter, startAfter + commonSeq.length)
            .map(function (each) {
                return ['=', each]
            })
    var beforeRight = before.slice(startBefore + commonSeq.length)
    var afterRight = after.slice(startAfter + commonSeq.length)

//        return diff(beforeLeft, afterLeft);
    return formatters.union(diff(beforeLeft, afterLeft), equal, diff(beforeRight, afterRight))
}

var orderedSetDiff = function (before, after) {
    var diffRes = diff(before, after)
    var result = []
    diffRes.forEach(function (each) {
        switch (each[0]) {
            case '=':
                result.push(each)
                break
            case '-':
                result.push((after.indexOf(each[1]) > -1) ? ['x', each[1]] : ['-', each[1]])
                break
            case '+':
                result.push((before.indexOf(each[1]) > -1) ? ['p', each[1]] : ['+', each[1]])
        }
    })
    return result
}

var compress = function (diff) {
    var result = []
    var modifier
    var section = []
    diff.forEach(function (each) {
        if (modifier && (each[0] == modifier)) {
            section.push(each[1])
        } else {
            if (modifier) result.push([modifier, section])
            section = [each[1]]
            modifier = each[0]
        }
    })
    if (modifier) result.push([modifier, section])
    return result
}
</script>
<script>
    console.log('*** TEST 1 ***');
    var before = [1, 2, 3, 4, 5];
    var after = [1, 3, 4, 7, 5];
    console.log('before', before);
    console.log('after', after);
    var diffRes = diff(before, after);
    console.log(diffRes.toString());
//    console.log(compress(diffRes).toString());

    console.log('*** TEST 2 ***');
    var before = [1, 2, 3, 4, 5]
    var after = [1, 6, 2, 3, 5, 4]
    console.log('before', before);
    console.log('after', after);
    var diffRes = diff(before, after)
    console.log(diffRes.toString());
    var diffRes2 = orderedSetDiff(before, after);
    console.log(diffRes2.toString());


    console.log('*** TEST 3 ***');
    var j = JSON.stringify;
    j = function (a) {
        return a
    };

    var _1 = j({ name: 'Adam'});
    var _2 = j({ name: 'Brian'});
    var _3 = j({ name: 'Cindy'});
    var _4 = j({ name: 'David'});
    var _5 = j({ name: 'Edward'});
    var _6 = j({ name: 'Frank'});
    var arr = [_1, _2, _3, _4, _5, _6];

    var i = function (v) {
        return arr.indexOf(v)
    };

    var before = [i(_1), i(_2), i(_3), i(_4), i(_5)]
    var after = [i(_1), i(_6), i(_2), i(_3), i(_5), i(_4)]
    console.log('before', before);
    console.log('after', after);
    var diffRes = diff(before, after)
    console.log(diffRes.toString());
    var diffRes2 = orderedSetDiff(before, after);
    console.log(diffRes2.toString());
</script>
</body>
</html>